/*
 * Generated by breeze-generator (https://github.com/weibreeze/breeze-generator)
 * Schema: testmsg.breeze
 * Date: 2022/2/17
 */

package test_msg

import (
	"errors"
	"github.com/weibreeze/breeze-go"
	"strconv"
)


const (
	MyEnumE1 MyEnum = 1
	MyEnumE2 MyEnum = 2
	MyEnumE3 MyEnum = 3
)

type MyEnum int
func (m MyEnum) WriteTo(buf *breeze.Buffer) error {
	return breeze.WriteMessageWithoutType(buf, func(buf *breeze.Buffer) {
		breeze.WriteInt32Field(buf, 1, int32(m))
	})
}

func (m MyEnum) ReadFrom(buf *breeze.Buffer) error {
	return errors.New("can not read enum by Message.ReadFrom, Enum.ReadEnum is expected. name:" + m.GetName())
}

func (m MyEnum) ReadEnum(buf *breeze.Buffer, asAddr bool) (breeze.Enum, error) {
	var number int32
	e := breeze.ReadMessageField(buf, func(buf *breeze.Buffer, index int) (err error) {
		switch index {
		case 1:
			err = breeze.ReadInt32(buf, &number)
		default: //skip unknown field
			_, err = breeze.ReadValue(buf, nil)
		}
		return err
	})
	if e == nil {
		var result MyEnum
		switch number {
		case 1:
			result = MyEnumE1
		case 2:
			result = MyEnumE2
		case 3:
			result = MyEnumE3
		default:
			return nil, errors.New("unknown enum number " + strconv.Itoa(int(number)))
		}
		if asAddr {
			return &result, nil
		}
		return result, nil
	}
	return nil, e
}

func (m MyEnum) GetName() string {
	return myEnumBreezeSchema.Name
}

func (m MyEnum) GetAlias() string {
	return myEnumBreezeSchema.Alias
}

func (m MyEnum) GetSchema() *breeze.Schema {
	return myEnumBreezeSchema
}

type TestMsg struct {
	MyInt int32
	MyString string
	MyMap map[string]*TestSubMsg
	MyArray []*TestSubMsg
	SubMsg *TestSubMsg
	MyEnum *MyEnum
	EnumArray []*MyEnum
}

func (t *TestMsg) WriteTo(buf *breeze.Buffer) error {
	return breeze.WriteMessageWithoutType(buf, func(buf *breeze.Buffer) {
		breeze.WriteInt32Field(buf, 1, t.MyInt)
		breeze.WriteStringField(buf, 2, t.MyString)
		if len(t.MyMap) > 0 {
			breeze.WriteMapField(buf, 3, len(t.MyMap), func(buf *breeze.Buffer) {
				first := true
				for k1, v1 := range t.MyMap {
					if first {
						breeze.WriteStringType(buf)
						breeze.WriteMessageType(buf, v1.GetName())
						first = false
	}
					breeze.WriteString(buf, k1, false)
					v1.WriteTo(buf)
				}
			})
		}
		if len(t.MyArray) > 0 {
			breeze.WriteArrayField(buf, 4, len(t.MyArray), func(buf *breeze.Buffer) {
				first := true
				for _, v1 := range t.MyArray {
					if first {
						breeze.WriteMessageType(buf, v1.GetName())
						first = false
	}
					v1.WriteTo(buf)
				}
			})
		}
		if t.SubMsg != nil {
			breeze.WriteMessageField(buf, 5, t.SubMsg)
		}
		if t.MyEnum != nil {
			breeze.WriteMessageField(buf, 6, t.MyEnum)
		}
		if len(t.EnumArray) > 0 {
			breeze.WriteArrayField(buf, 7, len(t.EnumArray), func(buf *breeze.Buffer) {
				first := true
				for _, v1 := range t.EnumArray {
					if first {
						breeze.WriteMessageType(buf, v1.GetName())
						first = false
	}
					v1.WriteTo(buf)
				}
			})
		}
	})
}

func (t *TestMsg) ReadFrom(buf *breeze.Buffer) error {
		return breeze.ReadMessageField(buf, func(buf *breeze.Buffer, index int) (err error) {
		switch index {
		case 1:
			err = breeze.ReadInt32(buf, &t.MyInt)
		case 2:
			err = breeze.ReadString(buf, &t.MyString)
		case 3:
			size, err := breeze.ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyMap = make(map[string]*TestSubMsg, size)
			err = breeze.ReadPacked(buf, size, true, func(buf *breeze.Buffer) error {
				k1, err := breeze.ReadStringWithoutType(buf)
				if err != nil {
					return err
				}
				v1 := &TestSubMsg{}
				err = v1.ReadFrom(buf)
				if err == nil {
					t.MyMap[k1] = v1
				}
				return err
			})
			return err
		case 4:
			size, err := breeze.ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyArray = make([]*TestSubMsg, 0, size)
			err = breeze.ReadPacked(buf, size, false, func(buf *breeze.Buffer) error {
				v1 := &TestSubMsg{}
				err = v1.ReadFrom(buf)
				if err == nil {
					t.MyArray = append(t.MyArray, v1)
				}
				return err
			})
			return err
		case 5:
			t.SubMsg = &TestSubMsg{}
			return breeze.ReadByMessage(buf, t.SubMsg)
		case 6:
			var value MyEnum
			result, err := breeze.ReadByEnum(buf, value, true)
			if err == nil {
				t.MyEnum = result.(*MyEnum)
			}
		case 7:
			size, err := breeze.ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.EnumArray = make([]*MyEnum, 0, size)
			err = breeze.ReadPacked(buf, size, false, func(buf *breeze.Buffer) error {
				var enum MyEnum
				result, err := enum.ReadEnum(buf, true)
				if err == nil {
					t.EnumArray = append(t.EnumArray, result.(*MyEnum))
				}
				return err
			})
			return err
		default: //skip unknown field
			_, err = breeze.ReadValue(buf, nil)
		}
		return err
	})
}

func (t *TestMsg) GetName() string {
	return testMsgBreezeSchema.Name
}

func (t *TestMsg) GetAlias() string {
	return testMsgBreezeSchema.Alias
}

func (t *TestMsg) GetSchema() *breeze.Schema {
	return testMsgBreezeSchema
}

type TestSubMsg struct {
	MyString string
	MyInt int32
	MyInt64 int64
	MyFloat32 float32
	MyFloat64 float64
	MyByte byte
	MyBytes []byte
	MyMap1 map[string][]byte
	MyMap2 map[int32][]int32
	MyArray []int32
	MyBool bool
}

func (t *TestSubMsg) WriteTo(buf *breeze.Buffer) error {
	return breeze.WriteMessageWithoutType(buf, func(buf *breeze.Buffer) {
		breeze.WriteStringField(buf, 1, t.MyString)
		breeze.WriteInt32Field(buf, 2, t.MyInt)
		breeze.WriteInt64Field(buf, 3, t.MyInt64)
		breeze.WriteFloat32Field(buf, 4, t.MyFloat32)
		breeze.WriteFloat64Field(buf, 5, t.MyFloat64)
		breeze.WriteByteField(buf, 6, t.MyByte)
		breeze.WriteBytesField(buf, 7, t.MyBytes)
		if len(t.MyMap1) > 0 {
			breeze.WriteMapField(buf, 8, len(t.MyMap1), func(buf *breeze.Buffer) {
				breeze.WriteStringType(buf)
				breeze.WriteBytesType(buf)
				for k1, v1 := range t.MyMap1 {					breeze.WriteString(buf, k1, false)
					breeze.WriteBytes(buf, v1, false)
				}
			})
		}
		if len(t.MyMap2) > 0 {
			breeze.WriteMapField(buf, 9, len(t.MyMap2), func(buf *breeze.Buffer) {
				breeze.WriteInt32Type(buf)
				breeze.WritePackedArrayType(buf)
				for k1, v1 := range t.MyMap2 {					breeze.WriteInt32(buf, k1, false)
					breeze.WritePackedArray(buf, false, len(v1), func(buf *breeze.Buffer) {
					breeze.WriteInt32ArrayElems(buf, v1)
					})
				}
			})
		}
		if len(t.MyArray) > 0 {
			breeze.WriteArrayField(buf, 10, len(t.MyArray), func(buf *breeze.Buffer) {
				breeze.WriteInt32ArrayElems(buf, t.MyArray)
			})
		}
		breeze.WriteBoolField(buf, 11, t.MyBool)
	})
}

func (t *TestSubMsg) ReadFrom(buf *breeze.Buffer) error {
		return breeze.ReadMessageField(buf, func(buf *breeze.Buffer, index int) (err error) {
		switch index {
		case 1:
			err = breeze.ReadString(buf, &t.MyString)
		case 2:
			err = breeze.ReadInt32(buf, &t.MyInt)
		case 3:
			err = breeze.ReadInt64(buf, &t.MyInt64)
		case 4:
			err = breeze.ReadFloat32(buf, &t.MyFloat32)
		case 5:
			err = breeze.ReadFloat64(buf, &t.MyFloat64)
		case 6:
			err = breeze.ReadByte(buf, &t.MyByte)
		case 7:
			err = breeze.ReadBytes(buf, &t.MyBytes)
		case 8:
			size, err := breeze.ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyMap1 = make(map[string][]byte, size)
			err = breeze.ReadPacked(buf, size, true, func(buf *breeze.Buffer) error {
				k1, err := breeze.ReadStringWithoutType(buf)
				if err != nil {
					return err
				}
				v1, err := breeze.ReadBytesWithoutType(buf)
				if err == nil {
					t.MyMap1[k1] = v1
				}
				return err
			})
			return err
		case 9:
			size, err := breeze.ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyMap2 = make(map[int32][]int32, size)
			err = breeze.ReadPacked(buf, size, true, func(buf *breeze.Buffer) error {
				k1, err := breeze.ReadInt32WithoutType(buf)
				if err != nil {
					return err
				}
				v1, err := breeze.ReadInt32Array(buf, false)
				if err == nil {
					t.MyMap2[k1] = v1
				}
				return err
			})
			return err
		case 10:
			t.MyArray, err = breeze.ReadInt32Array(buf, true)
		case 11:
			err = breeze.ReadBool(buf, &t.MyBool)
		default: //skip unknown field
			_, err = breeze.ReadValue(buf, nil)
		}
		return err
	})
}

func (t *TestSubMsg) GetName() string {
	return testSubMsgBreezeSchema.Name
}

func (t *TestSubMsg) GetAlias() string {
	return testSubMsgBreezeSchema.Alias
}

func (t *TestSubMsg) GetSchema() *breeze.Schema {
	return testSubMsgBreezeSchema
}


var myEnumBreezeSchema  *breeze.Schema
var testMsgBreezeSchema  *breeze.Schema
var testSubMsgBreezeSchema  *breeze.Schema

func init() {
	myEnumBreezeSchema = &breeze.Schema{Name: "test_msg.MyEnum"}
	myEnumBreezeSchema.PutFields(&breeze.Field{Index: 1, Name: "enumNumber", Type: "int32"})

	testMsgBreezeSchema = &breeze.Schema{Name: "test_msg.TestMsg"}
	testMsgBreezeSchema.PutFields(&breeze.Field{Index: 1, Name: "myInt", Type: "int32"})
	testMsgBreezeSchema.PutFields(&breeze.Field{Index: 2, Name: "myString", Type: "string"})
	testMsgBreezeSchema.PutFields(&breeze.Field{Index: 3, Name: "myMap", Type: "map<string, TestSubMsg>"})
	testMsgBreezeSchema.PutFields(&breeze.Field{Index: 4, Name: "myArray", Type: "array<TestSubMsg>"})
	testMsgBreezeSchema.PutFields(&breeze.Field{Index: 5, Name: "subMsg", Type: "TestSubMsg"})
	testMsgBreezeSchema.PutFields(&breeze.Field{Index: 6, Name: "myEnum", Type: "MyEnum"})
	testMsgBreezeSchema.PutFields(&breeze.Field{Index: 7, Name: "enumArray", Type: "array<MyEnum>"})

	testSubMsgBreezeSchema = &breeze.Schema{Name: "test_msg.TestSubMsg"}
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 1, Name: "myString", Type: "string"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 2, Name: "myInt", Type: "int32"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 3, Name: "myInt64", Type: "int64"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 4, Name: "myFloat32", Type: "float32"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 5, Name: "myFloat64", Type: "float64"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 6, Name: "myByte", Type: "byte"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 7, Name: "myBytes", Type: "bytes"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 8, Name: "myMap1", Type: "map<string, bytes>"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 9, Name: "myMap2", Type: "map<int32, array<int32>>"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 10, Name: "myArray", Type: "array<int32>"})
	testSubMsgBreezeSchema.PutFields(&breeze.Field{Index: 11, Name: "myBool", Type: "bool"})
}
